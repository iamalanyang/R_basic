# 向量

### 利用 c(...) 建立向量，但切記向量元素必須是同個資料屬性。

```r
> c(1, 2, 3)
[1] 1 2 3

> c(1, TRUE, "test") # 全部都變成 character
[1] "1"    "TRUE" "test"

> c(1.1, TRUE, "test") # 全部都變成 character
[1] "1.1"  "TRUE" "test"

> c(1+2i, TRUE, "test") # 全部都變成 character
[1] "1+2i" "TRUE" "test"

> c(1, TRUE) # 全部自動轉成 integer
[1] 1 1

> c(1.1, TRUE) # 全部自動轉成 numeric
[1] 1.1 1.0

> c(1+2i, TRUE) # 全部自動轉成 complex
[1] 1+2i 1+0i

> c(1, 1.1) # 全部自動轉成 numeric
[1] 1.0 1.1

> c(1, 1.1, 1+2i) # 全部自動轉成 complex
[1] 1.0+0i 1.1+0i 1.0+2i
```
註：經由以上比較後，可以得到當放入的形態不同時，會被轉成同一形態，且可以每個形態的強弱不同，以下是強到弱排序。

character > complex > numeric > integer > logical

### 透過指標與名稱提取資料
我們可以透過以下二種方式取得向量元素。

+ 指標
+ 元素名稱

另外可以搭配 [] 或 [[]]，這樣分別會回傳向量元素的所有資訊或向量元素的數值，總共可以分成以下四種狀況。

+ x[i]：回傳向量元素所有資訊
+ x[[i]]：只回傳向量元素的值
+ x[元素名稱]：回傳向量元素所有資訊
+ x[元素名稱]：只回傳向量元素的值

```r
> x <- c(joe=12, vicky=14, bob=17)

> x[1]
joe
 12
> x[[1]]
[1] 12

> x["joe"]
joe
 12
> x[["joe"]]
[1] 12

> x[1]
joe
 12
> x[[1]]
[1] 12

> x[1:2] # 一次取多個向量元素
  joe vicky
   12    14
```


### c(...) 類似的函數 x:y、seq 與 rep

+ x:y：回傳 x 到 y 的整數向量，所以 x 與 y 都是整數。
+ seq(s, e, by)：產生一個等差級數的向量。
    + s 是初始值
    + e 是結束值
    + by 是遞增值，預設是 1
+ rep(x, times, each)：產生一個重覆循環的向量。
    + x 是需重覆循環的數值
    + times 是重覆循環次數
    + each 是 x 內元素重覆的次數

```r
> 1:5
[1] 1 2 3 4 5

> seq(1, 5)
[1] 1 2 3 4 5

> seq(1, 5, 0.3) # 就算沒有剛好加到跟結束值一樣也沒關係
[1] 1.0 1.3 1.6 1.9 2.2 2.5 2.8 3.1 3.4 3.7 4.0 4.3 4.6 4.9

> rep(c(1, 2, 3), times = 3, each = 2)
[1] 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3

> rep(1:4, times = 3, each = 2)
[1] 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4 1 1 2 2 3 3 4 4
```
### 基本相關函數

+ 向量加減乘除
+ length：計算向量中的元素個數。
+ sum：將向量所有元素加總。
+ prod：將向量所有元素相乘。
+ cumsum：回傳元素累加向量。
+ cumprod：回傳元素累乘向量。
+ sort：將向量元素排列，產生排序過的向量。
+ rank：回傳各向量元素的排序值。

```r
> c(3, 4, 2) + c(3, 4, 2)
[1] 6 8 4
> c(3, 4, 2) - c(3, 4, 2)
[1] 0 0 0
> c(3, 4, 2) * c(3, 4, 2)
[1]  9 16  4
> c(3, 4, 2) / c(3, 4, 2)
[1] 1 1 1

> length(c(3, 4, 2))
[1] 3

> sum(c(3, 4, 2))
[1] 9

> cumsum(c(3, 4, 2))
[1] 3 7 9

> cumprod(c(3, 4, 2))
[1]  3 12 24

> prod(c(3, 4, 2))
[1] 24

> sort(c(3, 4, 2))
[1] 2 3 4

> rank(c(3, 4, 2))
[1] 2 3 1
```

上述向量加減乘除時，向量個數都是一樣的狀況，但不同的狀況會發生什麼結果，請看以下測試。

### 加跟減

如果長度較長的向量長度是較短的倍數的話是可以相加或相減的。

```r
> c(1, 2) + c(1, 2, 3)
[1] 2 4 4
警告訊息：
In c(1, 2) + c(1, 2, 3) : 較長的物件長度並非較短物件長度的倍數

> c(1, 2) + c(1, 2, 3, 4) # 1+1 2+2 1+3 1+4
[1] 2 4 4 6
```


### 乘跟除

乘跟除的情況與加跟減狀況一致，只是當長度不是倍數時會有結果但也會警告。

```r
> c(1, 2) * c(1, 2, 3) # 1*1 2*2 1*3
[1] 1 4 3
警告訊息：
In c(1, 2) * c(1, 2, 3) : 較長的物件長度並非較短物件長度的倍數

> c(1, 2) * c(1, 2, 3, 4) # 1*1 2*2 1*3 2*4
[1] 1 4 3 8
```


